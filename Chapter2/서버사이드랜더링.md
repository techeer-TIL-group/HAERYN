## 1. 랜더링이란?

 랜더링 전략이란, 웹페이지 또는 웹 앱을 웹 브라우저에 제공하는 방법입니다. <br>
Gatsby같은 프레임워크는 정적 페이지를 제공하기에 좋고, <br>
다른 프레임워크는 서버에서 랜더링한 페이지를 제공하기에 좋아요.

  Next.js에서는 <br>
어떤 페이지를 빌드 시점에 정적으로 생성하고, <br>
어떤 페이지를 실행 시점에 동적으로 제공할 것인지 정할 수 있습니다. <br>
애플리케이션의 특정 페이지에 대한 요청이 있을 때마다 페이지를 다시 생성할 수도 있습니다. <br>
꼭 클라이언트에서 랜더링해야 할 컴포넌트도 지정할 수 있어요. <br>

<br>

## 2. 서버 사이드 랜더링(SSR)

  일반적인 랜더링 방법은 대부분 서버 사이드 랜더링입니다. <br>
PHP, 루비, 파이썬 같은 경우에는, <br>
HTML 페이지를 웹 브라우저로 전송하기 전, 서버에서 모두 랜더링합니다. <br>
그리고 해당 페이지의 모든 js코드가 적재되면 동적으로 페이지 내용을 랜더링합니다. <br>

  Next.js도 요청에 따라 서버에서 HTML 페이지를 동적으로 랜더링하고 브라우저로 전송할 수 있어요. <br>
하이드레이션이란, <br>
서버에서 랜더링한 페이지에 스크립트 코드를 집어넣어서 나중에 웹 페이지를 동적으로 처리하는 것입니다.

  예를 들어 어떤 사람이 작성한 모든 글을 한 페이지에 랜더링 한다고 가정해보죠. <br>
서버는, 사용자가 페이지에 접근할 떄 페이지를 랜더링해서 결과로 생성한 HTML 페이지를 클라로 전송합니다. <br>
브라우저는, 페이지에서 요청한 모든 스크립트를 다운로드한 다음 DOM 위에 각 스크립트 코드를 하이드레이션합니다. <br>
결과적으로 페이지를 새로 고치지 않고도 아무 문제 없이 사용자와 웹 페이지와 상호작용할 수 있습니다. <br>
이 하이드레이션 덕분에 웹 앱은 싱글페이지 애플리케이션(SPA)처럼 작동됩니다. <br>
클라이언트 사이드 랜더링과 서버 사이드 랜더링의 장점이 모두 적용되죠. 

<br>

## 3. 서버 사이드 랜더링(SSR)의 장점

### 1) 안전성

  페이지를 서버에서 랜더링한다. <br>
이 말은 바꿔 말하면, 쿠키관리, 주요 API 데이터 검증 등과 같은 것을 서버에서 처리하기에, <br>
중요 대이터를 클라에 노출할 필요가 없으므로 더욱 안전합니다.

### 2) 웹 사이트 호환성
  클라 환경이 js를 사용하지 못할 정도로 오래된 브라우저를 써도 웹 페이지를 제공할 수 있습니다.

### 3) SEO
  클라에서 서버가 랜더링한 HTML 콘텐츠를 받으므로, <br>
봇이나 웹 크롤러 같은 검색엔진 웹 문서 수집기가 페이지를 랜더링할 필요가 없습니다.
따라서 웹 애플리케이션의 SEO 점수가 높아집니다.

<br>

## 4. 서버 사이드 랜더링(SSR)의 단점

  클라이언트가 요청할 때마다, 페이지를 다시 랜더링 할 수 있는 서버가 반드시 필요합니다. <br>
CSR, 정적 사이트 생성의 경우 <br>
정적 HTML 파일을 Vercel, Netlify 같은 클라우드 서비스에 배포하고 클라에 제공할 수 있습니다. <br>
웹 앱을 배포할 경우, 다른 방식보다 더 많은 자원을 소모하고, 부하가 많으며 유지 보수 비용이 증가합니다.

<br>

  또한 페이지에 대한 요청을 처리하는 시간이 길어집니다.<br>
페이지가 외부 API 또는 데이터 소스에 접근할 경우, <br>
해당 페이지를 랜더링 할 때마다 API나 데이터 소스를 다시 요청하게 되는 원리입니다. <br>
서버에서 랜더링한 페이지 같의 이동은, 클라 또는 정적 생성 페이지간 이동보다 느립니다. <br>
다행히도 이에 대한 Next.js의 특수 기능이 있어요. <br>

  Next.js는 빌드시점에 정적으로 페이지를 만듭니다. <br>
페이지에서 외부 API를 호출하거나 DB에 접근 하는 등 동적 작업을 원한다면 해당 함수를 export해야합니다. <br>
예을 들어 Next.js의 getServerSideProps라는 예약함수를 사용한다고 가정합시다. <br>
기본적으로 페이지에 대한 요청이 들어오면 서버가 REST API를 호출해서 필요한 사용자 정보를 가져옵니다. <br>
세부 과정은 아래와 같습니다. <br>

1) getServerSideProps라는 비동기 함수를 export합니다. <br>
빌드 과정에서 Next.js는 이 함수를 export하는 모든 페이지를 찾아서, 서버가 페이지 요청 처리할 때 본 함수를 호출하도록 합니다. <br>
해당 함수 내의 코드는 항상 서버에서만 실행되요. <br>
   <br>
2) 이 함수는 props 속성값을 갖는 객체를 반환합니다. <br>
Next.js는 이 props를 컴포넌트로 전달해서 서버와 클라 모두 props에 접근하고 사용할 수 있게 합니다. <br>
fetch API는 Next.js를 통해 서버에서 실행되기에, 별도의 폴리필로 끼워넣을 필요 없습니다.
   <br>    
3) IndexPage 함수를 수정해서 props를 인자로 받습니다. <br>
이 props는 아까 함수에서 반환한 props의 모든 내용을 갖고 있습니다.
   <br>

  이후 코드를 배포 및 실행하면 <br>
Next.js는 외부 API를 호출해서 필요 데이터를 모두 가져오고 IndexPage를 서버에서 동적으로 랜더링합니다. <br>
이제 사용자 별로 서로 다른 페이지를 볼 수 있어요.

<br>

  브라우저 전용 API를 사용해야 하는 컴포넌트가 있다면, 반드시 브라우저에서 랜더링하도록 명시적으로 지정해야합니다. <br>
Next.js는 페이지를 기본적으로 서버에서 랜더링 하기에, window, document와 같은 객체나 API를 제공하지 않습니다. <br>
이런 부족한 면은 CSR로 채웁시다.




